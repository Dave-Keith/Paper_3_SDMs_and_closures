---
title: "Distribution of Yellowtail Flounder and Atlantic Cod on Georges Bank"
output: 
  flexdashboard::flex_dashboard:
    theme: flatly
  orientation: columns
  vertical_layout: fill
  # storyboard: true
runtime: shiny
#runtime: shiny_prerendered #  This is supposed to render all the plots right off the bat, so slower first time, but makes moving between pages really quick
---

```{r global, include=FALSE}

# Point this to wherever you have clones/saved the github repo the remainder of the code should 

direct.proj <- "github" # This forces the analysis to run from Github without user input
#direct.proj <- "D:/Github/" # If you have cloned the github repo for this paper you can run this locally.

req.packages <- c("shiny", 
                  "shinyWidgets",
                  "flexdashboard",
                  "readr",
                  "leaflet",
                  "DT",
                  "tidyverse",
                  "lubridate",
                  "plotly",
                  "sf",
                  "sp",
                  "data.table",
                  "units",
                  "cowplot",
                  "knitr",
                  "animation",
                  "RCurl",
                  "boot",
                  'concaveman',
                  'ggthemes',
                  "nngeo",
                  "marmap",
                	"ggplot2",
                	"stars",
                	"tmaptools",
                	"rnaturalearth",
                	"rnaturalearthdata",
                	"raster",
                	"rgdal",
                	"RStoolbox",
                	"pals",
                	"ggnewscale",
                	"ggspatial",
                  'devtools',
                  'rlist')
# If you don't have the packages install them + give a heads up that you are
new.packages <- req.packages[!(req.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)>0) 
{
  cat(paste0("Heads up, I have to install these packages for this to work:", new.packages ))
  #wanna.install <- readline(prompt = "If you want to install these package(s) enter 'y': ")
  #if(tolower(wanna.install) == 'y') 
  install.packages(new.packages,repos = "http://cran.us.r-project.org") #else { stop("You didn't want to install the packages so this script does not work.")}
}

# You also need to install this github repo if you do not have it.
hi.res <- any(installed.packages()[,"Package"] %in% "rnaturalearthhires")
if(hi.res == F) devtools::install_github("https://github.com/ropensci/rnaturalearthhires/")
  

################Section 1    Load data and functions ########################## ################Section 1    Load data and functions ##########
# Now load the packages
invisible(lapply(req.packages, library, character.only = TRUE))

#direct.proj <- "Y:/Projects/GB_time_area_closure_SPERA/"
#direct.proj <- "d:/NAS/Projects/GB_time_area_closure_SPERA/"; dir.tmp <- direct.proj

 funs <- c("https://raw.githubusercontent.com/Mar-Scal/Assessment_fns/master/Maps/convert_coords.R",
           "https://raw.githubusercontent.com/Mar-Scal/Assessment_fns/master/Maps/combo_shp.R",
           "https://raw.githubusercontent.com/Mar-scal/Assessment_fns/master/Maps/add_alpha_function.R",
           "https://raw.githubusercontent.com/Mar-scal/Assessment_fns/master/Maps/pectinid_projector_sf.R",
           "https://raw.githubusercontent.com/Mar-scal/Assessment_fns/master/Maps/centre_of_gravity.R",
           "https://raw.githubusercontent.com/Dave-Keith/Paper_2_SDMs/master/Scripts/predict_fields.R",
           "https://raw.githubusercontent.com/Mar-Scal/Assessment_fns/master/Maps/convert_inla_mesh_to_sf.R")
    # Now run through a quick loop to load each one, just be sure that your working directory is read/write!
    for(fun in funs) 
    {
      download.file(fun,destfile = basename(fun))
      source(paste0(getwd(),"/",basename(fun)))
      file.remove(paste0(getwd(),"/",basename(fun)))
    } # end for(un in funs)


# Convert a factor to a number
factor.2.number <- function(x) {as.numeric(levels(x))[x]}

if(direct.proj != 'github') load(paste0(direct.proj,"Paper_3_SDMs_and_closures/data/INLA_meshes.RData"))
if(direct.proj == 'github') load(url("https://raw.githubusercontent.com/Dave-Keith/Paper_3_SDMs_and_closures/master/data/INLA_meshes.RData"))

# Here is the data we need, this comes from Step 3 INLA_mesh_for_gb_surveys_and_scallop_survey.R
if(direct.proj != 'github') load(paste0(direct.proj,"Paper_3_SDMs_and_closures/data/INLA_mesh_input_data.RData"))
if(direct.proj == 'github') load(url("https://raw.githubusercontent.com/Dave-Keith/Paper_3_SDMs_and_closures/master/data/INLA_mesh_input_data.RData"))

# Here I load the Prediction mesh/grid.
if(direct.proj != 'github') load(paste0(direct.proj,"Paper_2_SDMs/data/Prediction_mesh.RData"))
if(direct.proj == 'github') load(url("https://raw.githubusercontent.com/Dave-Keith/Paper_3_SDMs_and_closures/master/data/Prediction_mesh.RData"))


# The predicted data for 2017 to 2019, this  file only contains the object all.resids which has the summary of the residuals and prediction error for the 2017-2019 data.
if(direct.proj != 'github') load(paste0(direct.proj,"Paper_3_SDMs_and_closures/data/Prediction_and_Rand_fields_all_models.RData"))
if(direct.proj == 'github') load(url("https://raw.githubusercontent.com/Dave-Keith/Paper_3_SDMs_and_closures/master/data/Prediction_and_Rand_fields_all_models.RData"))

if(direct.proj != 'github') dat.final <- readRDS(paste0(direct.proj,"Paper_3_SDMs_and_closures/data/survey_data_1970_2019.rds"))
if(direct.proj == 'github') dat.final <- readRDS(url("https://raw.githubusercontent.com/Dave-Keith/Paper_3_SDMs_and_closures/master/data/survey_data_1970_2019.rds"))

# The meshes


theme_set(theme_few(base_size = 10))


# Next get the EEZ so we can divide up Canada ad the US

temp <- tempfile()
      # Download this to the temp directory you created above
download.file("https://raw.githubusercontent.com/Mar-scal/GIS_layers/master/EEZ/EEZ.zip", temp)
# Figure out what this file was saved as
temp2 <- tempfile()
# Unzip it
unzip(zipfile=temp, exdir=temp2)
# Now read in the shapefile
eez.all <- st_read(paste0(temp2, "/EEZ.shp"))
rm(temp,temp2)
clp.eez <- st_as_sf(data.frame(X = c(-70,-70,-62.2,-62.2),Y = c(39,44,44,39)),coords = c("X","Y"),crs = 4326)
clp.eez <- st_cast(st_combine(clp.eez),"POLYGON")
eez.all <- eez.all %>% st_transform(4326)
tmp <- st_intersection(eez.all,clp.eez)
eez.can <- concaveman(tmp)
eez.can <- eez.can %>% st_transform(32619)
eez.can <- st_zm(eez.can,drop=T)
# I need to make the mesh.grid a nicer sf object
mesh.grid <- st_sf(mesh.grid)
grid.outline <- st_cast(mesh.grid,"POINT")
grid.outline <- concaveman(grid.outline) 
mesh.sf <- inla.mesh2sf(mesh.gf)
mesh <- mesh.sf$triangles
mesh <- st_sf(mesh,crs = st_crs(mesh.grid))

clp.poly <- st_as_sf(data.frame(X = c(508000,508000,900000,650000,600000,550000),
                                 Y=c(4540000,4350000,4674000,4674000,4661000,4622000),ID=1),coords = c("X","Y"),crs= 32619)
clp.poly <- st_cast(st_combine(clp.poly),"POLYGON")
# # Now use the bigger clp with this other clip to get a nice clipped GB area...
clp.pred <- st_intersection(clp,clp.poly)
clp.can <- st_intersection(clp.pred,eez.can)
# The groundfish domain within the study area.
gf.pred <- st_intersection(eez.can,clp.pred)
# for testing purposes...
#input <- data.frame(prob = 0.8, species = "cod", survey = "RV_survey")
bp <- pecjector(area="GOM",plot=F,repo = 'github',add_layer = list(land = 'grey',eez = 'eez',nafo = 'main',scale.bar = 'tl'),c_sys = 32619,buffer = 0.05) + theme_map()

bp2 <- pecjector(c_sys = 32619,area = list(x=c(580000,780000), y = c(4530000,4680000),crs = 32619),
                     add_layer = list(eez = 'eez',nafo = 'main',scale.bar = 'tl'),plot=F,
                     add_custom = list(obj = clp.poly,fill=NA)) + theme_map()

bp.pred <- pecjector(c_sys = 32619,area = list(x=c(380000,7800000), y = c(4400000,4750000),crs = 32619),
                     add_layer = list(land = 'grey',eez = 'eez',nafo = 'main',scale.bar = 'tl'),plot=F,
                     add_custom = list(obj = clp.pred,fill=NA)) + theme_map()

# Bring in the closure locations so we can add those to the spatial figures and get the subsetting done with...

temp <- tempfile()
# Download this to there88
download.file("https://raw.githubusercontent.com/Mar-scal/GIS_layers/master/other_boundaries/other_boundaries.zip", temp)
# Figure out what this file was saved as
temp2 <- tempfile()
# Unzip it
unzip(zipfile=temp, exdir=temp2)
# Now grab the individual shape files I want.
CA1 <- st_read(dsn = paste0(temp2,"/CA1.shp"))
CA1 <- st_transform(CA1,crs = 32619)
CA1.clip <- st_intersection(CA1,clp.pred)
CA2 <- st_read(dsn = paste0(temp2,"/CA2.shp"))
CA2 <- st_transform(CA2,crs = 32619)
CA2.clip <- st_intersection(CA2,clp.pred)
yt.closures <- st_read(dsn =paste0(temp2,"/yt_closures.shp"))
yt.closures <- st_transform(yt.closures,crs = 32619)
# Clip the YT closure box down at the bottom to constrain it to be in Canada!
tst <-st_intersection(yt.closures,eez.can)
yt.closures <- yt.closures %>% dplyr::filter(year <= 2019) # We're only running this show up to 2019...
cod.closures <- st_read(dsn =paste0(temp2,"/cod_closures.shp"))
cod.closures <- st_transform(cod.closures,crs = 32619)
cod.closures <- cod.closures %>% dplyr::filter(year <= 2019) # We're only running this show up to 2019...
rm(temp,temp2)
# Now grab the coordinates for the survey boundaries for GBa and gbb, inside of the survey_boundaries zip.
temp <- tempfile()
# Download this to there
download.file("https://raw.githubusercontent.com/Mar-scal/GIS_layers/master/survey_boundaries/survey_boundaries.zip", temp)
# Figure out what this file was saved as
temp2 <- tempfile()
# Unzip it
unzip(zipfile=temp, exdir=temp2)
# And we get GBa and GBb from there
gba.surv <- st_read(dsn = paste0(temp2,"/GBa.shp"))
gbb.surv <- st_read(dsn = paste0(temp2,"/GBb.shp"))
# Make an 'all of gb' sf object
gb.surv <- st_union(gba.surv,gbb.surv)
# This removes holes, still have one small artifact out to the east, but it matters little...
gb.surv <- nngeo::st_remove_holes(gb.surv)
gb.surv <- st_transform(gb.surv,crs= 32619)
scal.area <- st_area(gb.surv) %>% set_units("km^2")
# Put all the closures together so we can easily plot them.
all.closures <- c(st_geometry(CA1.clip),st_geometry(CA2.clip),st_geometry(yt.closures),st_geometry(cod.closures),st_geometry(gf.pred))
rm(temp,temp2)

## Add a variable to dat.final....
dat.final$surveys <- "Spring"
dat.final$surveys[dat.final$survey == "nmfs-fall"] <- "Fall"
dat.final$surveys[dat.final$survey == "RV"] <- "Winter"


```


# Indicators on Georges Bank

## Column {.sidebar data-width="250"}

```{r spatial-1}

sliderInput("prob", label = "Encounter Probability",
            min = 0, max = 1, value = 0, step = 0.05)
radioButtons("species_sm","Which Stock",
            choices = c("Atlantic Cod" = "cod",
                        "Yellowtail Flounder" = "yt"))
radioButtons("indicator_sm","Which Indicator",
            choices = c("Core Area" = "pred",
                        "Standard Deviation" = "pred.sd",
                        "SD Distance" = "sd.dist",
                        "Standardized SD Distance" = "stan.sd.dist"))
selectInput("survey_sm","Which Season",
            choices = c("Winter (DFO)" = "RV_survey",
                        "Spring (NMFS)" = "nmfs-spring_survey",
                        "Fall (NMFS)" = "nmfs-fall_survey"))

actionButton("go",label="",icon =icon("redo"))
#input <- data.frame(prob = 0.75, species_sm = 'yt', survey_sm = "nmfs-spring_survey",indicator_sm = 'pred')
# So we can do our reactive stuff here, which is potentially nice, this is essentially my 'conductive element"
res <- reactive({
              #Make this run if we hit our go button, see how we added an isolate command to all the places in which we were using an input$ object to stop recalcs.
             input$go
             isolate({
             res <- pred.dat[[paste0(input$species_sm,"_PA ",input$survey_sm,sep="")]]
             #rf <- rand.field.pred[[paste0(input$species_sm,"_PA ",input$survey_sm,sep="")]]
              # Easy way to pick 3 vs 5 year since I kept both columns but NA'ed the one not being used
             if(all(is.na(res$years_3)))
             {
               n.eras <- length(unique(res$years_5))
               eras <- factor.2.number(unique(res$years_5))
             } # End if loop
              
             # Easy way to pick 3 vs 5 year since I kept both columns but NA'ed the one not being used
             if(all(is.na(res$years_5)))
             {
               n.eras <- length(unique(res$years_3))
               eras <- factor.2.number(unique(res$years_3))
             } # end if loop
              
             res <- st_as_sf(res,coords = c("X","Y"), crs = st_crs(mesh.grid),remove = F)
             #mesh.tmp <- st_sf(rep(st_sf(mesh.sf$vertices)$geometry,n.eras), crs = st_crs(mesh.grid))
             #mesh.tmp$ID <- rf$ID <- 1:nrow(rf)
             #rf$era <- sort(rep(eras,nrow(mesh.sf$vertices)))
             #rf <- merge(mesh.tmp,rf, by = "ID")
            
             # Now for some reason my prediction grid doesn't quite line up with my prediciton mesh, so clip the mesh to match
             res <- st_join(mesh.grid,res)
             #rf <- st_intersection(rf,clp.pred)
             for(n in min(eras):max(eras))
             {
               if(all(is.na(res$years_3)))
               {
               yrs <- paste0(substr(dat.final %>% filter(years_5 == n, survey == unique(res$survey)) %>% dplyr::summarise(min = min(year)),3,4),"-",
                             substr(dat.final %>% dplyr::filter(years_5 == n, survey == unique(res$survey)) %>% dplyr::summarise(max = max(year)),3,4))
               if(substr(yrs[1],1,2) > 30) { yrs <- paste0(19,yrs)} else {yrs <- paste0(20,yrs)}
               res$yrs[res$years_5==n] <- yrs
               #rf$yrs[rf$era == n] <- yrs
               }
                
               if(all(is.na(res$years_5)))
               {
                 yrs <- paste0(substr(dat.final %>% filter(years_3 == n, survey == unique(res$survey)) %>% dplyr::summarise(min = min(year)),3,4),"-",
                               substr(dat.final %>% dplyr::filter(years_3 == n, survey == unique(res$survey)) %>% dplyr::summarise(max = max(year)),3,4))
                 if(substr(yrs[1],1,2) > 30) { yrs <- paste0(19,yrs)} else {yrs <- paste0(20,yrs)}
                 res$yrs[res$years_3==n] <- yrs
                # rf$yrs[rf$era == n] <- yrs
               }
                
             } # end   for(n in min(eras):max(eras))
            
             res <- res[!is.na(res$yrs),]
             #rf <- rf[!is.na(rf$yrs),]
             # So calculating area is smart using that set units, though they are all idenitcal...
             res$area <- res %>% st_area() %>% set_units("km^2")
             # Now we can calculate the sd distance metrics, very simple happily!
             res$pred.bin <- round(res$pred,digits =2)
             hmm <- data.frame(res) %>% dplyr::group_by(pred.bin) %>% dplyr::summarize(mn.sd.bin = mean(pred.sd))
             res <- left_join(res,hmm,by=c("pred.bin"))
             res <- res %>% dplyr::mutate(sd.dist = pred.sd-mn.sd.bin, stan.sd.dist = (pred.sd-mn.sd.bin)/mn.sd.bin)
             # Make the 'response' variable we want, this was a bit convoluted thanks to sf...
             tmp <- res  %>% st_set_geometry(NULL)
             res$response <- as.numeric(unlist(tmp[input$indicator_sm]))
             # Now subset the data...
             res <- res %>% filter(pred >= input$prob)# THIS IS SUPER IMPORTANT!!  WHAT IS THE probability we are looking at for this.
 
             res
            }) #end isolate
        })

# # Grab the random fields, basically same as above but outputs the rf() object for later use.


# I also want a yrs object I can use later, again repetitive with above....
yrs <- reactive({
              #Make this run if we hit our go button, see how we added an isolate command to all the places in which we were using an input$ object to stop recalcs.
             input$go
             isolate({
             tmp <-  pred.dat[[paste0(input$species_sm,"_PA ",input$survey_sm,sep="")]]
              # Easy way to pick 3 vs 5 year since I kept both columns but NA'ed the one not being used
             if(all(is.na(tmp$years_3)))
             {
               n.eras <- length(unique(tmp$years_5))
               eras <- factor.2.number(unique(tmp$years_5))
             } # End if loop
              
             # Easy way to pick 3 vs 5 year since I kept both columns but NA'ed the one not being used
             if(all(is.na(tmp$years_5)))
             {
               n.eras <- length(unique(tmp$years_3))
               eras <- factor.2.number(unique(tmp$years_3))
             } # end if loop
  
             yrs <- NA
             count <- 0
             for(n in min(eras):max(eras))
             {
               
               if(all(is.na(tmp$years_3)))
               {
               count=count+1
               yrs[count] <- paste0(substr(dat.final %>% filter(years_5 == n, survey == unique(tmp$survey)) %>% dplyr::summarise(min = min(year)),3,4),"-",
                             substr(dat.final %>% dplyr::filter(years_5 == n, survey == unique(tmp$survey)) %>% dplyr::summarise(max = max(year)),3,4))
               if(substr(yrs[count],1,2) > 30) { yrs[count] <- paste0(19,yrs[count])} else {yrs[count] <- paste0(20,yrs[count])}
               }
                
               if(all(is.na(tmp$years_5)))
               {
                 count=count+1
                 yrs[count] <- paste0(substr(dat.final %>% filter(years_3 == n, survey == unique(tmp$survey)) %>% dplyr::summarise(min = min(year)),3,4),"-",
                               substr(dat.final %>% dplyr::filter(years_3 == n, survey == unique(tmp$survey)) %>% dplyr::summarise(max = max(year)),3,4))
                 if(substr(yrs[count],1,2) > 30)  { yrs[count] <- paste0(19,yrs[count])} else {yrs[count] <- paste0(20,yrs[count])}
               }
             } # end   for(n in min(eras):max(eras))
            
            yrs
            #
            }) #end isolate
        })



# Calculate the center of gravity 
 cog <- reactive({
            cog <- as.data.table(res())[,cog.calc(X,Y,pred), by = yrs]
            cog <- st_as_sf(cog,coords = c('x','y'), crs= st_crs(mesh.grid), remove=F)
            cog <- cog[order(cog$yrs),]

        })
# Calculate the area....
 resp.era <- reactive({
                  resp.era <- data.frame(res()) %>% dplyr::group_by(yrs,.drop=F) %>% dplyr::summarize(pred = as.numeric(sum(area)),
                                                                                                      pred.sd = mean(pred.sd),
                                                                                                      sd.dist = mean(sd.dist), 
                                                                                                      stan.sd.dist = mean(stan.sd.dist)
                                                                                                      ) 
                  
                  # In case we are missing some years...
                  all.years <- data.frame(yrs = yrs())
                  obs.years <- data.frame(yrs = unique(resp.era$yrs)[order(unique(resp.era$yrs))])
                  if(nrow(all.years) != nrow(obs.years))
                  {
                   miss.yrs <- data.frame(yrs = setdiff(all.years$yrs,obs.years$yrs),pred = 0)
                   resp.era <- bind_rows(resp.era,miss.yrs) 
                   resp.era <- resp.era[order(resp.era$yrs),]
                  }# end if(nrow(all.years) != nrow(us.years))
                  
                  loc.text = c(600000,4440000) # I might make this an input, but we'll see...
                  resp.era$X <- loc.text[1]
                  resp.era$Y <- loc.text[2]
                  resp.era$eras <- as.numeric(factor(resp.era$yrs, labels =1:length(unique(resp.era$yrs))))
                  resp.era <- st_as_sf(resp.era,crs=st_crs(mesh.grid),coords = c("X","Y"), remove=F)
                  
                  #n.eras <- length(unique(res()$years_5))
                  #if(n.eras ==1) n.eras <- length(unique(res()$years_3)) # Length one means it's an NA!
                  # Make the 'response' variable we want, this was a bit convoluted thanks to sf...
                  tmp <- resp.era  %>% st_set_geometry(NULL)
                  resp.era$response <- as.numeric(unlist(tmp[input$indicator_sm]))
                  resp.era$lab <- NA
                  for(k in 1:nrow(resp.era)) resp.era$lab[k] <- paste0("Area==~",round(resp.era$pred[k],digits=0),"*km^2")
                  #resp.era$lab <- lab
                  # Get this going for all years in the data...
                  all.years$first.years <- as.numeric(substr(all.years$yrs,1,4))
                  all.years$last <- substr(all.years$yrs,6,7)
                  all.years$last.years <- ifelse(as.numeric(all.years$last) < 30,2000+as.numeric(all.years$last),1900+as.numeric(all.years$last))   
                  # Now get a combo of the all.years and surv years object that identifes the era by year...
                  if(input$survey_sm == "RV_survey") surv.years <- unique(dat.final$year[dat.final$survey == "RV"])
                  if(input$survey_sm != "RV_survey") surv.years <- unique(dat.final$year[dat.final$survey == "nmfs-spring"]) # Both NMFS surveys get us to the same place
                  yr.era <- data.frame(year = surv.years,yrs = NA)
                  for(i in 1:nrow(all.years)) yr.era$yrs[which(yr.era$year >= all.years$first.years[i] & yr.era$year <= all.years$last.years[i])] <- all.years$yrs[i]
                  resp.era <- left_join(resp.era,yr.era,by='yrs')
                  resp.era
              })

resp.can.vs.us <- reactive({
                    pf.can <- st_intersection(res(),eez.can)
                    if(nrow(pf.can) > 0) pf.can$area <-  pf.can %>% st_area() %>% set_units("km^2") %>% as.numeric()
                    # If no data fill it with 0's...
                    if(nrow(pf.can) == 0) pf.can <- data.frame(yrs = yrs(),area=0)
                    pf.can$country <- "GB - Canada"
                    # Now the US....
                    pf.us <- st_difference(res(),eez.can)
                    if(nrow(pf.us) > 0) pf.us$area <-  pf.us %>% st_area() %>% set_units("km^2") %>% as.numeric()
                    if(nrow(pf.us) == 0) pf.us <- data.frame(yrs = yrs(),area=0)
                    pf.us$country <- "GB - U.S."

                    #pf.area <- bind_rows(pf.us, pf.can)
                    area.can <- pf.can  %>% dplyr::group_by(country,yrs,.drop=F) %>% 
                                            dplyr::summarize(pred = as.numeric(sum(area)),
                                                             pred.sd = mean(pred.sd),
                                                             sd.dist = mean(sd.dist), 
                                                             stan.sd.dist = mean(stan.sd.dist)) %>% data.frame()
                    
                    area.us <- pf.us  %>% dplyr::group_by(country,yrs,.drop=F) %>% 
                                          dplyr::summarize(pred = as.numeric(sum(area)),
                                                           pred.sd = mean(pred.sd),
                                                           sd.dist = mean(sd.dist), 
                                                           stan.sd.dist = mean(stan.sd.dist)) %>% data.frame()
                    
                    # In case we are missing some years...
                    all.years <- data.frame(yrs = yrs())
                    can.years <- data.frame(yrs = unique(area.can$yrs)[order(unique(area.can$yrs))])
                    us.years <- data.frame(yrs = unique(area.us$yrs)[order(unique(area.us$yrs))])
                    # If missing some years in Canada
                    if(nrow(all.years) != nrow(can.years))
                    {
                     miss.can.yrs <- data.frame(country = unique(area.can$country),yrs = setdiff(all.years$yrs,can.years$yrs),pred = 0,
                                                pred.sd = NA, sd.dist=NA,stan.sd.dist=NA) 
                     area.can <- bind_rows(area.can,miss.can.yrs) 
                     area.can <- area.can[order(area.can$yrs),]
                    }# end if(nrow(all.years) != nrow(can.years))
                    # If missing some years in US
                    if(nrow(all.years) != nrow(us.years))
                    {
                    miss.us.yrs <- data.frame(country = unique(area.us$country),yrs = setdiff(all.years$yrs,us.years$yrs),pred = 0,
                                              pred.sd = NA, sd.dist=NA,stan.sd.dist=NA) 
                    area.us <- bind_rows(area.us,miss.us.yrs) 
                    area.us <- area.us[order(area.us$yrs),]
                    }# end if(nrow(all.years) != nrow(us.years))
                    
                    resp.can.vs.us <- bind_rows(area.can,area.us)
                    resp.can.vs.us$pred <- as.numeric(resp.can.vs.us$pred)  
                    resp.can.vs.us$eras <- as.numeric(factor(resp.can.vs.us$yrs, labels =1:length(unique(resp.can.vs.us$yrs))))
                    # Make the 'response' variable we want...
                    resp.can.vs.us$response <- as.numeric(unlist(resp.can.vs.us[input$indicator_sm]))
                    # Get this going for all years in the data...
                    all.years$first.years <- as.numeric(substr(all.years$yrs,1,4))
                    all.years$last <- substr(all.years$yrs,6,7)
                    all.years$last.years <- ifelse(as.numeric(all.years$last) < 30,2000+as.numeric(all.years$last),1900+as.numeric(all.years$last))   
                    # Now get a combo of the all.years and surv years object that identifes the era by year...
                    if(input$survey_sm == "RV_survey") surv.years <- unique(dat.final$year[dat.final$survey == "RV"])
                    if(input$survey_sm != "RV_survey") surv.years <- unique(dat.final$year[dat.final$survey == "nmfs-spring"]) # Both NMFS surveys get us to the same place
                    yr.era <- data.frame(year = surv.years,yrs = NA)
                    for(i in 1:nrow(all.years)) yr.era$yrs[which(yr.era$year >= all.years$first.years[i] & yr.era$year <= all.years$last.years[i])] <- all.years$yrs[i]
                    resp.can.vs.us <- left_join(resp.can.vs.us,yr.era,by='yrs')
                    resp.can.vs.us
                  })
 

```

## Column {.tabset}

### Figure

```{r ts-something}

renderPlot({
   # Set up my colour ramp for the maps, stolen from pectinid
  # Note we need a couple of isolates and an action button trigger in hear as we have 2 input$ calls
  input$go
  isolate({
    # Some handy names...
    spec <- "Cod"
    surv = "Winter"
    if(input$species_sm == 'yt') spec <- "Yellowtail"
    if(input$survey_sm == 'nmfs-spring_survey') surv <- "Spring"
    if(input$survey_sm == 'nmfs-fall_survey')  surv <- "Fall"
    
    col <- addalpha(pals::viridis(101),1)
    if(input$indicator_sm == "pred") 
    {
      brk <- seq(input$prob,1,by=0.05)
      col <- col[((100*input$prob)+1):101]
      leg.name <- "Encounter Probability"
    } #end EP if statement
    
    if(input$indicator_sm == "stan.sd.dist") 
    {
      brk <- seq((floor(10*min(res()$response))/10),(ceiling(10*max(res()$response))/10),by=0.15)
      leg.name <- "Standardized SD Distance"
    }# ENd Standardized sd distance if 
    
    if(input$indicator_sm == c("pred.sd")) 
    {
      brk <- seq(floor(10*min(res()$response))/10,ceiling(10*max(res()$response))/10,by=0.025)
      leg.name <- "Standard Deviation"
    } # End SD if
    
    if(input$indicator_sm == c('sd.dist')) 
    {
      brk <- seq(floor(100*min(res()$response))/100,ceiling(100*max(res()$response))/100,by=0.02)
      leg.name <- "SD Distance"
    }
    
    if(length(brk) <= 6) hgt <- unit(0.5,'cm')
    if(length(brk) > 6 & length(brk) <= 12) hgt <- unit(1.75,'cm')
    if(length(brk) > 12) hgt <- unit(2.5,'cm')
    lims <- range(brk)
    
    
    sf <- scale_fill_gradientn(colours = col, limits=lims,breaks=brk,name=leg.name)
    sc <- scale_colour_gradientn(colours = col, limits=lims,breaks=brk,name=leg.name)
    n.row =2
    print(class(resp.era()))
    # Now for the plot...
    plt<- bp + geom_sf(data = res()  ,aes(fill = response,colour=response))+
      facet_wrap(~yrs,nrow=n.row) +
      coord_sf(datum=32619) + sf + sc + #theme_map() +
      geom_sf_text(data = resp.era() , aes(label = lab),parse=T) +
      theme(legend.key.height =hgt,text = element_text(size=22),legend.position = 'right') +
      #geom_text(data=area.t,aes(label =as.expression(bquote(Area== .(pred)~km^2)),parse=T) ) +
      #annotate('text',x=resp.era$X,y=resp.era$Y, label=tst,parse=T) +
      # Note for the >= symbol to show up correctly in a pdf use cairo_pdf rather than just pdf! Just trying to avoid using an expression here..
      ggtitle(paste(leg.name,"for", spec,"in the",surv))

    plt
          }) # end isolate
})

```

### Video

```{r video, fig.width=20, fig.height=15}

# Only make the image if I go to this page or if I change an input with this isolate.
renderImage(deleteFile=F,{
         input$go# Tell this to update when I hit the action button. 
         isolate({
          # Here's a hack to autmatically resize the figure to the size of the page
          # That took a while to figure out!
          
          wid <- names(session$clientData)[grepl('width',names(session$clientData))][1]
          p.width <- (session$clientData[[wid]])#[grepl('width',names(session$clientData))][1])
          print(p.width)
          ht <- names(session$clientData)[grepl('height',names(session$clientData))][1]
          p.height <- (session$clientData[[ht]])#[grepl('width',names(session$clientData))][1])
          print(p.height)
          # Some names...
          spec <- "Cod"
          surv = "Winter"
          if(input$species_sm == 'yt') spec <- "Yellowtail"
          if(input$survey_sm == 'nmfs-spring_survey') surv <- "Spring"
          if(input$survey_sm == 'nmfs-fall_survey')  surv <- "Fall"
          
          # Set up my colour ramp for the maps, stolen from pectinid
          col <- addalpha(pals::viridis(101),1)
          if(input$indicator_sm == "pred") 
          {
            brk <- seq(input$prob,1,by=0.05)
            col <- col[((100*input$prob)+1):101]
            leg.name <- "Encounter Probability"
          } #end EP if statement
          
          if(input$indicator_sm == "stan.sd.dist") 
          {
            brk <- seq((floor(10*min(res()$response))/10),(ceiling(10*max(res()$response))/10),by=0.15)
            leg.name <- "Standardized SD Distance"
          }# ENd Standardized sd distance if 
          
          if(input$indicator_sm == c("pred.sd")) 
          {
            brk <- seq(floor(10*min(res()$response))/10,ceiling(10*max(res()$response))/10,by=0.025)
            leg.name <- "Standard Deviation"
          } # End SD if
          
          if(input$indicator_sm == c('sd.dist')) 
          {
            brk <- seq(floor(100*min(res()$response))/100,ceiling(100*max(res()$response))/100,by=0.02)
            leg.name <- "SD Distance"
          }
          
          if(length(brk) <= 6) hgt <- unit(0.5,'cm')
          if(length(brk) > 6 & length(brk) <= 12) hgt <- unit(1.75,'cm')
          if(length(brk) > 12) hgt <- unit(2.5,'cm')
          lims <- range(brk)


          sf <- scale_fill_gradientn(colours = col, limits=lims,breaks=brk,name=leg.name)
          sc <- scale_colour_gradientn(colours = col, limits=lims,breaks=brk,name=leg.name)
          # A temp file to save the output.
          # This file will be removed later by renderImage
          #outfile <- tempfile(fileext='.gif')

         saveGIF(
         {
          ani.options(interval = 2, nmax = 50)
          eras <- sort(unique(res()$yrs))
          n.eras <- length(eras)
          #count = 0
          #vid <- NULL
          for (p in 1:n.eras)
          {
            clp <- res() %>% filter(yrs == eras[p])
            area.t <- resp.era() %>% filter(yrs == eras[p])
            vid <- bp + geom_sf(data = clp  ,aes(fill = response,colour=response))+
                        coord_sf(datum=32619) + sf + sc  +
                        geom_sf_text(data = area.t , aes(label = lab),parse=T,color="black") +
                        theme(legend.key.height =hgt,text = element_text(size=22),legend.position = 'right') +# theme_map()+
                        #geom_text(data=area.t,aes(label =as.expression(bquote(Area== .(pred)~km^2)),parse=T) ) +
                        #annotate('text',x=resp.era$X,y=resp.era$Y, label=tst,parse=T) +
                        # Note for the >= symbol to show up correctly in a pdf use cairo_pdf rather than just pdf! Just trying to avoid using an expression here..
                        ggtitle(paste(leg.name,"for", spec,"in the",surv,'from',eras[p]))

            print(vid)
          }
          #}
          }, movie.name = paste0(getwd(),'/test.gif'),ani.width = p.width, ani.height = p.height)

         # Here's how you bring in an external image
         list(src = paste0(getwd(),"/test.gif"),
         contentType = 'image/gif')
         #ui <- fluidPage(plotOutput(output$vid))
         }) # end isolate
})



```

### Time Series

```{r time-series}

renderPlot({
  input$go# Tell this to update when I hit the action button. 
  isolate({
         # Set up the y-axis label.
     if(input$indicator_sm == "pred")
     { 
       yl <- "Area (km²)"
       yb = seq(0,40000,1500); yb2 <- yb
       ylm <- c(0,NA)
     }

     if(input$indicator_sm == "pred.sd") 
     {
       yl <- "Standard Deviation"
       yb <- pretty(c(0,0.25)); yb2 <- yb
       ylm <- c(0,0.25)
     }

     if(input$indicator_sm == "sd.dist") 
     {
       yl <- "SD Distance"
       yb <- pretty(c(min(resp.era()$response,na.rm=T),max(resp.era()$response,na.rm=T)))
       yb2 <- pretty(c(min(resp.can.vs.us()$response,na.rm=T),max(resp.can.vs.us()$response,na.rm=T)))
       ylm <- c(NA,NA)
     }

     if(input$indicator_sm == "stan.sd.dist") 
     {
       yl <- "Standardized SD Distance"
       yb <- pretty(c(min(resp.era()$response,na.rm=T),max(resp.era()$response,na.rm=T)))
       yb2 <- pretty(c(min(resp.can.vs.us()$response,na.rm=T),max(resp.can.vs.us()$response,na.rm=T)))
       ylm <- c(NA,NA)
     }
   area.ts <-  ggplot(data = resp.era()) +  geom_line(aes(x=year, y = as.numeric(response)),size=1.5) + 
                                            geom_point(aes(x=year, y = as.numeric(response)),size=2.5,color="blue") +
                                            ylab(yl) + xlab("") +# Get squared with Alt + 0178.. bam
                                            scale_y_continuous(breaks = yb, limits = ylm) + 
                                            #scale_x_continuous(breaks = unique(resp.era()$eras),labels = unique(resp.era()$yrs)) + 
                                            theme_few() + theme(text = element_text(size=22),
                                                                axis.text = element_text(size=14)) + 
                                            labs(subtitle = "Georges Bank") + 
                                            theme(plot.subtitle = element_text(hjust = 0.5,element_text(size = 18)),
                                                  #axis.text.x = element_text(angle = -45, vjust = 0.5),
                                                  axis.text = element_text(size=14))
   
   plt.resp.can.vs.us <- ggplot(resp.can.vs.us()) + geom_line(aes(x=year, y = response),lwd=1.5) + facet_wrap(~ country) + 
                                            geom_point(aes(x=year, y = response),size=2.5,color="blue") +
                                            scale_y_continuous(breaks = yb2, limits = ylm) + 
                                            #scale_x_continuous(breaks = unique(resp.can.vs.us()$eras),labels = unique(resp.can.vs.us()$yrs)) +
                                            xlab("")  + ylab("") +  theme_few() + 
                                            theme(text = element_text(size=26),
                                                  #axis.text.x = element_text(angle = -45, vjust = 0.5, size=14),
                                                  axis.text = element_text(size=14))
   # Sadly something appears to be wrong with plotly and shiny right now so just ggplots for now...
   ts.plts <- v.plt <- plot_grid(area.ts,plt.resp.can.vs.us,nrow=1,rel_widths = c(1,2))
   ts.plts
   })
   #shiny::renderUI({plotly::plotlyOutput("p_env", height = "100%")})

})
```


### Center of Gravity

```{r cog}

renderPlot({
  input$go# Tell this to update when I hit the action button. 
  isolate({
   cog.sd.plt <-  bp2 + geom_label(data = cog(),aes(x=x, y = y,label=substr(yrs,3,8)),nudge_x = -7500,nudge_y=3500,size=4) +
      geom_errorbar(data = cog(),aes(x= x,ymin=y - 3*se.y,ymax=y + 3*se.y),colour = "blue",width=0,size=2)  +
      geom_errorbar(data = cog(),aes(y= y,xmin=x - 3*se.x,xmax=x + 3*se.x),colour = "blue",width=0,size=2)  +
      xlab("") + ylab("") + theme(panel.border = element_rect(colour = "black", fill=NA, size=1))
   # Sadly something appears to be wrong with plotly and shiny right now so just ggplots for now...
   cog.sd.plt })
   #shiny::renderUI({plotly::plotlyOutput("p_env", height = "100%")})

})
```



<!-- Next up are the figures that are related to the closures -->

# Indicators for Closures

## Column {.sidebar data-width="250"}


```{r closure-ts}

sliderInput("prob_pred", label = "Encounter Probability",
            min = 0, max = 1, value = 0, step = 0.05)
radioButtons("species_pred","Which Stock",
             choices = c("Atlantic cod" = "cod",
                         "Yellowtail flounder" = "yt"))
radioButtons("indicator_pred","Which Indicator",
            choices = c("Encounter Probability" = "pred",
                        "Standard Deviation" = "pred.sd",
                        "SD Distance" = "sd.dist",
                        "Standardized SD Distance" = "stan.sd.dist"))
selectInput("survey_pred","Which Season",
            choices = c("Winter (DFO)" = "RV_survey",
                        "Spring (NMFS)" = "nmfs-spring_survey",
                        "Fall (NMFS)" = "nmfs-fall_survey"))
radioButtons("closure","Closure",
             choices = c("All closures" = "all",
                         "Closed Area I" = "CA1",
                         "Closed Area II" = "CA2",
                         "Cod Closure" = "cod",
                         "Yellowtail Closure" = "yt",
                         "Groundfish Closure" = "gf"))
sliderInput('year_pred', label="Survey Observations",min = 1972,max=2019,value = c(1987,2016),step=1,dragRange = T)
checkboxInput('show_pts', "Show survey points",value = T)
#checkboxGroupInput('pred_field', "Prediction Field",choices = c("3 year","5 year", "10 year"))

actionButton("go_pred",label="",icon =icon("redo"))

## Column {.sidebar data-width="250"}

#input <- list(species_pred = 'yt',prob_pred = 0.5,survey_pred = "nmfs-spring_survey",closure = 'yt',indicator_pred = 'pred.sd',year_pred = c(1987,2016))

preds.all <- reactive({
  # Make this run if we hit our go button, see how we added an isolate command to all the places in which we were using an input$ object to stop recalcs.
  input$go_pred
  isolate({
    preds.all <- pred.dat[[paste0(input$species_pred,"_PA ",input$survey_pred,sep="")]]
    
    # Easy way to pick 3 vs 5 year since I kept both columns but NA'ed the one not being used
    if(all(is.na(preds.all$years_3)))
    {
      n.eras <- length(unique(preds.all$years_5))
      eras <- factor.2.number(unique(preds.all$years_5))
    } # End if loop
    
    # Easy way to pick 3 vs 5 year since I kept both columns but NA'ed the one not being used
    if(all(is.na(preds.all$years_5)))
    {
      n.eras <- length(unique(preds.all$years_3))
      eras <- factor.2.number(unique(preds.all$years_3))
    } # end if loop
    
    preds.all <- st_as_sf(preds.all,coords = c("X","Y"), crs = st_crs(mesh.grid),remove = F)
    #mesh.tmp <- st_sf(rep(st_sf(mesh.sf$vertices)$geometry,n.eras), crs = st_crs(mesh.grid))
    
    # Now for some reason my prediction grid doesn't quite line up with my prediciton mesh, so clip the mesh to match
    preds.all <- st_join(mesh.grid,preds.all)
    
    for(n in min(eras):max(eras))
    {
      if(all(is.na(preds.all$years_3)))
      {
        yrs <- paste0(substr(dat.final %>% filter(years_5 == n, survey == unique(preds.all$survey)) %>% dplyr::summarise(min = min(year)),3,4),"-",
                      substr(dat.final %>% dplyr::filter(years_5 == n, survey == unique(preds.all$survey)) %>% dplyr::summarise(max = max(year)),3,4))
        if(substr(yrs[1],1,2) > 30) { yrs <- paste0(19,yrs)} else {yrs <- paste0(20,yrs)}
        preds.all$yrs[preds.all$years_5==n] <- yrs
        preds.all$first_year[preds.all$years_5==n] <- as.numeric(dat.final %>% 
                                                                   filter(years_5 == n, survey == unique(preds.all$survey)) %>% 
                                                                   summarise(min = min(year)))
      }
      
      if(all(is.na(preds.all$years_5)))
      {
        yrs <- paste0(substr(dat.final %>% filter(years_3 == n, survey == unique(preds.all$survey)) %>% dplyr::summarise(min = min(year)),3,4),"-",
                      substr(dat.final %>% dplyr::filter(years_3 == n, survey == unique(preds.all$survey)) %>% dplyr::summarise(max = max(year)),3,4))
        if(substr(yrs[1],1,2) > 30) { yrs <- paste0(19,yrs)} else {yrs <- paste0(20,yrs)}
        preds.all$yrs[preds.all$years_3==n] <- yrs
        preds.all$first_year[preds.all$years_3==n] <- as.numeric(dat.final %>% 
                                                                       filter(years_3 == n, survey == unique(preds.all$survey)) %>% 
                                                                       summarise(min = min(year)))
        
      }
      
    } # end   for(n in min(eras):max(eras))
    

    # So the key is the last thing is the dataframe we want...
  
    # So the key is the last thing is the dataframe we want...
    preds.all <- st_as_sf(preds.all,coords = c("X","Y"), crs = st_crs(mesh.grid),remove = F)
    # Now for some reason my prediction grid doesn't quite line up with my prediciton mesh, so clip the mesh to match
    #preds.all <- st_join(preds.all,grid.outline)
    # Now we can calculate the sd distance metrics, very simple happily!
    preds.all$pred.bin <- round(preds.all$pred,digits =2)
    hmm <- data.frame(preds.all) %>% dplyr::group_by(pred.bin) %>% dplyr::summarize(mn.sd.bin = mean(pred.sd))
    preds.all <- left_join(preds.all,hmm,by=c("pred.bin"))
    preds.all <- preds.all %>% dplyr::mutate(sd.dist = pred.sd-mn.sd.bin, stan.sd.dist = (pred.sd-mn.sd.bin)/mn.sd.bin)
    # Make the 'response' variable we want, this was a bit convoluted thanks to sf...
    tmp <- preds.all  %>% st_set_geometry(NULL)
    preds.all$response <- as.numeric(unlist(tmp[input$indicator_pred]))
    preds.all <- preds.all %>% filter(pred >= input$prob_pred)
    all.years <- data.frame(yrs = unique(preds.all$yrs)) 
    all.years$yrs <- all.years$yrs[order(all.years$yrs)]
    preds.all$area <- preds.all %>% st_area() %>% set_units("km^2")
    first.years <- unique(preds.all$first_year)
    # This year field is annoying and pointless
    preds.all <- preds.all[,-which(names(preds.all) =='year')]
  })
})
    # Take the predictions and get them for each closure area...
resp.era.all <- reactive({
  # Make this run if we hit our go button, see how we added an isolate command to all the places in which we were using an input$ object to stop recalcs.
  input$go_pred
  isolate({
    
    all.years <- data.frame(yrs = unique(preds.all()$yrs)) 
    if(input$survey_pred == "RV_survey") surv.years <- unique(dat.final$year[dat.final$survey == "RV"])
    if(input$survey_pred != "RV_survey") surv.years <- unique(dat.final$year[dat.final$survey == "nmfs-spring"]) # Both NMFS surveys get us to the same place
    all.years$yrs <- all.years$yrs[order(all.years$yrs)]
    all.years$first.years <- as.numeric(substr(all.years$yrs,1,4))
    all.years$last <- substr(all.years$yrs,6,7)
    all.years$last.years <- ifelse(as.numeric(all.years$last) < 30,2000+as.numeric(all.years$last),1900+as.numeric(all.years$last))   
    
    # Now get a combo of the all.years and surv years object that identifes the era by year...
    yr.era <- data.frame(year = surv.years,yrs = NA)
    for(i in 1:nrow(all.years)) yr.era$yrs[which(yr.era$year >= all.years$first.years[i] & yr.era$year <= all.years$last.years[i])] <- all.years$yrs[i]

    # Get the US area estimates.
    if(input$closure %in% c("gf","CA1","CA2"))
    {
      #First get the US area...
          # Get the US area to compare with the Closures
      area.us <- st_difference(preds.all(),eez.can)
      area.us$area <- area.us %>% st_area() %>% set_units("km^2")
      resp.era.us <- area.us  %>% group_by(yrs) %>% dplyr::summarize(pred = as.numeric(sum(area)),
                                                                     pred.sd = mean(pred.sd),
                                                                     sd.dist = mean(sd.dist), 
                                                                     stan.sd.dist = mean(stan.sd.dist)) %>% st_set_geometry(NULL)
      resp.era.us <- left_join(yr.era,resp.era.us,by="yrs")
      resp.era.us$loc <- "GB - U.S."
  
    
      #Get the closure area for each closure
      if(input$closure == 'gf')  cls.area <- st_intersection(preds.all(),eez.can)
      if(input$closure == "CA1") cls.area <- st_intersection(preds.all(),CA1)
      if(input$closure == "CA2") cls.area <- st_intersection(preds.all(),CA2)
      # Recalculate the area of each cell
      cls.area$area <- cls.area %>% st_area() %>% set_units("km^2")
      # Get the summary for the different indicators. drop the SF bit cause we don't need it for these time series...
      resp.era.all <- cls.area  %>% group_by(yrs) %>% dplyr::summarize(pred = as.numeric(sum(area)),
                                                                       pred.sd = mean(pred.sd),
                                                                       sd.dist = mean(sd.dist), 
                                                                       stan.sd.dist = mean(stan.sd.dist)) %>% st_set_geometry(NULL)
      # Now get this for all years of data
      resp.era.all <- left_join(yr.era,resp.era.all,by="yrs")
      # Give identify the closures in the data
      if(input$closure == 'gf') resp.era.all$loc <- "Groundfish Closure (GB - Can)"
      if(input$closure == 'CA1') resp.era.all$loc <- "CA I"
      if(input$closure == 'CA2') resp.era.all$loc <- "CA II"
      
      # Now stick the US and Canada stuff back together...
      resp.era.all <- bind_rows(resp.era.all,resp.era.us)
      resp.era.all$eras <- as.numeric(factor(resp.era.all$yrs, labels =1:length(unique(resp.era.all$yrs))))
    } # End the if we're gf/CA1/CA2
      
    # This get the area in Canada all set up for the Cod and YT closure.
    if(input$closure %in% c("cod","yt"))
    {
      if(input$species_pred == 'cod')
      {
        close.years <- data.frame(year = cod.closures$year)
        area.can <- st_intersection(preds.all(),eez.can)
        area.can$area <- area.can %>% st_area() %>% set_units("km^2")
        area.can <- area.can  %>% group_by(yrs) %>% dplyr::summarize(pred = as.numeric(sum(area)),
                                                                     pred.sd = mean(pred.sd),
                                                                     sd.dist = mean(sd.dist), 
                                                                     stan.sd.dist = mean(stan.sd.dist))   %>% st_set_geometry(NULL)
        area.can <- left_join(all.years,area.can,by="yrs")
        area.can$loc <- "Canada"
        # Now we have the problem of the COSF being in eras but the closures being in years since they vary in size.
        area.can$year <- as.numeric(substr(area.can$yrs,1,4))
        # This won't work for years in which the random field isn't 5 years, i.e. the first year in the yellowtail
        if(input$survey_pred == "RV_survey") 
        {
           area.first <- area.can %>% dplyr::filter(yrs == "1987-89") 
           area.can   <- area.can %>% dplyr::filter(yrs != "1987-89")
        } # end if surv == "winter" statement
        
        tmp <- NULL
        tmp2 <- NULL
        for(p in 0:4) 
        {
          tmp[[p+1]] <- area.can %>% dplyr::mutate(year = as.numeric(year) + p)
          if(input$survey_pred == "RV_survey" & p < 3)
          {
            tmp2[[p+1]] <- area.first %>% dplyr::mutate(year = as.numeric(year) + p) # Only needed for the Winter survey
          } # end if(surv == "Winter" & p < 3)
        } # end for p loop
        
        # Unwrap objects...
        area.can <- do.call('rbind',tmp)
        area.can <- area.can[order(area.can$year),]
        if(input$survey_pred == "RV_survey")
        {
          tmp2 <- do.call('rbind',tmp2)
          area.can <- bind_rows(tmp2,area.can) # Only needed for the Winter survey
        } # end if(surv == "Winter")
      } # End cod if...
      
      if(input$species_pred == 'yt')
      {
        close.years <- data.frame(year = yt.closures$year)
        area.can <- st_intersection(preds.all(),eez.can)
        area.can$area <- area.can %>% st_area() %>% set_units("km^2")
        area.can <- area.can  %>% group_by(yrs)  %>% dplyr::summarize(pred = as.numeric(sum(area)),
                                                                      pred.sd = mean(pred.sd),
                                                                      sd.dist = mean(sd.dist), 
                                                                      stan.sd.dist = mean(stan.sd.dist))  %>% st_set_geometry(NULL)
        area.can <- left_join(all.years,area.can,by="yrs")
        area.can$loc <- "Canada"
        # Now we have the problem of the COSF being in eras but the closures being in years since they vary in size.
        area.can$year <- as.numeric(substr(area.can$yrs,1,4))
        # This won't work for years in which the random field isn't 3 years, i.e. the first year in the yellowtail in spring. Winter and Fall happen to be fine for YT :-)
        if(input$survey_pred == "nmfs-spring_survey")
        {
          area.first <-   area.can %>% dplyr::filter(yrs == "1970-71") 
          area.can   <-   area.can %>% dplyr::filter(yrs != "1970-71")
        } # End surv == spring
            
        tmp <- NULL
        tmp2 <- NULL
        ####For the fall we have a 5 year loop, and all era's are 5 years long so easy peasy...
        if(input$survey_pred == "nmfs-fall_survey") { for(p in 0:4)  tmp[[p+1]] <- area.can %>% dplyr::mutate(year = as.numeric(year) + p) }
          
        # For the Winter and Spring surveys we have a 3 year field...
        if(input$survey_pred != "nmfs-fall_survey") 
        {  
          for(p in 0:2)
          {
            tmp[[p+1]] <- area.can %>% dplyr::mutate(year = as.numeric(year) + p)
            if(input$survey_pred == "nmfs-spring_survey" & p < 2)
            {
            tmp2[[p+1]] <- area.first %>% dplyr::mutate(year = as.numeric(year) + p) # Only needed for the Spring survey
            }  
          } # end p loop
        } # end surv fall statement
        # Unwrap and combine lists
        area.can <- do.call('rbind',tmp)
        area.can <- area.can[order(area.can$year),]
        if(input$survey_pred == "nmfs-spring_survey")
        {
          tmp2 <- do.call('rbind',tmp2)
          area.can <- bind_rows(tmp2,area.can) 
        } # End spring
      } #end the yt if
    } # End the cod/yt if
    
    # For the cod closure
    if(input$closure == "cod")  
    {
        # Now to get the cod closures right....
      tmp <- NULL
      for(i in 1:nrow(cod.closures))
      {
      year.to.pick <- all.years$first.years[max(which(all.years$first.years <= cod.closures$year[i]))]
      tmp[[i]] <- st_intersection(preds.all() %>% dplyr::filter(first_year == year.to.pick),cod.closures %>% dplyr::filter(year ==cod.closures$year[i]))
      }
      cls.area <- do.call('rbind',tmp)
      cls.area$area <- cls.area %>% st_area() %>% set_units("km^2")
      resp.era.all <- cls.area  %>% group_by(year)  %>% dplyr::summarize(pred = as.numeric(sum(area)),
                                                                         pred.sd = mean(pred.sd),
                                                                         sd.dist = mean(sd.dist), 
                                                                         stan.sd.dist = mean(stan.sd.dist)) 
      resp.era.all <- left_join(close.years,resp.era.all,by="year")
      resp.era.all$loc <- "Cod Closure"
      resp.era.all <- bind_rows(resp.era.all,area.can)

    } # end the cod closure
       
    if(input$closure == "yt")   
    {
      tmp <- NULL
      for(i in 1:nrow(yt.closures))
      {
      year.to.pick <- all.years$first.years[max(which(all.years$first.years <= yt.closures$year[i]))]
      tmp[[i]] <- st_intersection(preds.all() %>% dplyr::filter(first_year == year.to.pick),yt.closures %>% dplyr::filter(year ==yt.closures$year[i]))
      }
      cls.area <- do.call('rbind',tmp)
      cls.area$area <- cls.area %>% st_area() %>% set_units("km^2")
      resp.era.all <- cls.area  %>% group_by(year) %>% dplyr::summarize(pred = as.numeric(sum(area)),
                                                                        pred.sd = mean(pred.sd),
                                                                        sd.dist = mean(sd.dist), 
                                                                        stan.sd.dist = mean(stan.sd.dist)) 
      resp.era.all <- left_join(close.years,resp.era.all,by="year")
      resp.era.all$loc <- "Yellowtail Closure"
      resp.era.all <- bind_rows(resp.era.all,area.can)
      resp.era.all$loc <- factor(resp.era.all$loc,levels = c("Yellowtail Closure","Canada")) # Keep order of levels the same for figure.

    } # End of the yellowtail closure loop
     
    # If we have NA's for any of the core area predictions flip them to 0's.
    if(input$closure != "all") resp.era.all$pred[is.na(resp.era.all$pred)] <-0  
    if(input$closure == "all") resp.era.all <- NULL
     # Make any NA's = 0.
     resp.era.all$response <- as.numeric(unlist(resp.era.all[input$indicator_pred]))
     resp.era.all
     })
})
                       


preds <- reactive({
  # Make this run if we hit our go button, see how we added an isolate command to all the places in which we were using an input$ object to stop recalcs.
  input$go_pred
  isolate({
    preds <- preds.all()
    # So now we pick the era based on the first year of the pred_year chosen above because we need to pick something
    min.year <- min(input$year_pred)
    first.years <- sort(unique(preds$first_year))
    year.to.pick <- first.years[max(which(first.years <= min.year))]
    preds <- preds %>% filter(first_year == year.to.pick)
    # So the key is the last thing is the dataframe we want...
    #st_geometry(preds) <- st_geometry(mesh.grid)
    # # So calculating area is smart using that set units, though they are all idenitcal...
    #preds$area <- preds %>% st_area() %>% set_units("km^2")
    preds
    # # Calculate the center of gravity Here's a nice way to return an object with multiple ouptuts
  })# end isolate
})

resp.era.pred <- reactive({
  resp.era.pred <- data.frame(preds())  %>% summarize(tot.area = sum(area))
  #area.era
  loc.text = c(600000,4440000) # I might make this an input, but we'll see...
  resp.era.pred$X <- loc.text[1]
  resp.era.pred$Y <- loc.text[2]
  resp.era.pred <- st_as_sf(resp.era.pred,crs=st_crs(mesh.grid),coords = c("X","Y"), remove=F)
  resp.era.pred$lab <- paste0("Area==~",round(resp.era.pred$tot.area,digits=0),"*~km^2")
  resp.era.pred
})

```

## Column {.tabset}

### Spatial Predictions

-   These results show the indicators spatially on GB with a focus on each closure. The *Closure* options overlays the closure footprints on the map. The *Cod closure* and the *Yellowtail closure* are closures in Canada that are specific to the Canadian Offshore Scallop Fishery (COSF). 
    - *All closures* shows all closures on Georges Bank
    - *Closed Area I* adds this closure to the figure, represented with a solid red line.
    - *Closed Area II* adds this closure to the figure, represented with a solid grey line.
    - *Groundfish closure* adds this closure to the figure, represented with a dashed black line.
    - *Cod closure* adds this closure to the figure, represented with solid black lines.
    - *Yellowtail closure* adds this closure to the figure, represented with solid blue lines.




```{r spat-pred}

renderPlot({

  input$go_pred
  isolate({
    spec <- "Cod"
    surv = "Winter"
    if(input$species_pred == 'yt') spec <- "Yellowtail"
    if(input$survey_pred == 'nmfs-spring_survey') surv <- "Spring"
    if(input$survey_pred == 'nmfs-fall_survey')  surv <- "Fall"
    
    col <- addalpha(pals::viridis(101),1)
    col.pts <- c(col[1],col[101])
    if(input$indicator_pred == "pred") 
    {
      brk <- seq(input$prob_pred,1,by=0.05)
      col <- col[((100*input$prob_pred)+1):101]
      leg.name <- "Encounter Probability"
    } #end EP if statement
    
    if(input$indicator_pred == "stan.sd.dist") 
    {
      brk <- seq((floor(10*min(preds()$response))/10),(ceiling(10*max(preds()$response))/10),by=0.15)
      leg.name <- "Standardized SD Distance"
    }# ENd Standardized sd distance if 
    
    if(input$indicator_pred == c("pred.sd")) 
    {
      brk <- seq(floor(10*min(preds()$response))/10,ceiling(10*max(preds()$response))/10,by=0.025)
      leg.name <- "Standard Deviation"
    } # End SD if
    
    if(input$indicator_pred == c('sd.dist')) 
    {
      brk <- seq(floor(100*min(preds()$response))/100,ceiling(100*max(preds()$response))/100,by=0.02)
      leg.name <- "SD Distance"
    }
          
    if(length(brk) <= 6) hgt <- unit(0.5,'cm')
    if(length(brk) > 6 & length(brk) <= 12) hgt <- unit(1.75,'cm')
    if(length(brk) > 12) hgt <- unit(2.5,'cm')
    lims <- range(brk)


    sf <- scale_fill_gradientn(colours = col, limits=lims,breaks=brk,name=leg.name)
    sc <- scale_colour_gradientn(colours = col, limits=lims,breaks=brk,name=leg.name)

    predict.pts <- dat.final %>% filter(year %in% min(input$year_pred):max(input$year_pred), surveys ==  surv)
    predict.pts <- st_as_sf(predict.pts,coords = c("X","Y"),crs = st_crs(mesh.grid))
    predict.pts <- st_intersection(predict.pts,clp.pred)
    if(spec == "Cod") predict.pts$response <- predict.pts$cod_PA
    if(spec == "Yellowtail") predict.pts$response <- predict.pts$yt_PA
    predict.pts$response <- factor(predict.pts$response, levels = c(0,1),labels = c("Absent","Present"))
    sfp <- scale_fill_manual(values = col.pts,name = "Survey Observation")
    # Facet version of the above NOTE HOW THE YEARS ARE F'd up now...
    plt.pred <- bp.pred + geom_sf(data = preds() ,aes(fill = response,colour=response))+ sf + sc +
      geom_sf_text(data = resp.era.pred() , aes(label = lab),parse=T, size=8)  +
      #geom_sf(data=gbb.surv,fill=NA,linetype = 'dashed',size=0.5) +
      #geom_sf(data=gb.surv,fill=NA,linetype = 'dashed',size=0.5) +
      theme_map() + theme(legend.key.height =hgt,text = element_text(size=22),legend.position = "right") +
      ggtitle(paste(leg.name,"for", spec,"in the",surv))+
      labs(caption = paste("Note the prediction field era shown is",preds()$yrs[1]))#+
      #coord_sf(x=c(380000,780000), y = c(4400000,4750000))
    
    if(input$show_pts == T) plt.pred <- plt.pred + new_scale("fill") + geom_sf(data=predict.pts,aes(fill = response),color='black',shape=21,size=4,alpha=0.2) + sfp 

    if(!is.null(input$closure))
    {
      if(input$closure == "CA1")
      {
        x.bnd <- c(st_bbox(CA1)$xmin,st_bbox(CA1)$xmax)
        y.bnd <- c(st_bbox(CA1)$ymin,st_bbox(CA1)$ymax)
        plt.pred <- plt.pred + geom_sf(data = CA1.clip,fill=NA,color = "firebrick",size=1.5)+ 
                               coord_sf(xlim = x.bnd,ylim=y.bnd,expand=T)
      } # end if CA1
      
      if(input$closure == "CA2") 
      {
        x.bnd <- c(st_bbox(CA2)$xmin,st_bbox(CA2)$xmax)
        y.bnd <- c(st_bbox(CA2)$ymin,st_bbox(CA2)$ymax)
        plt.pred <- plt.pred + geom_sf(data = CA2.clip,fill=NA,color = "grey50",size=1.5) + 
                               coord_sf(xlim = x.bnd,ylim=y.bnd,expand=T)
      } #end if CA2
      
      if(input$closure == "gf") 
      {
        x.bnd <- c(st_bbox(gf.pred)$xmin,st_bbox(gf.pred)$xmax)
        y.bnd <- c(st_bbox(gf.pred)$ymin,st_bbox(gf.pred)$ymax)
        
        plt.pred <- plt.pred + geom_sf(data = gf.pred,fill=NA,color = "black",linetype = 'dashed',size=1.5)  + 
                               coord_sf(xlim = x.bnd, ylim=y.bnd, expand=T)
        
      } #end if gf
      if(input$closure == "cod")
      {
        x.bnd <- c(st_bbox(cod.closures)$xmin,st_bbox(cod.closures)$xmax)
        y.bnd <- c(st_bbox(cod.closures)$ymin,st_bbox(cod.closures)$ymax)
        if(min(input$year_pred) < 2006) c.closures <- cod.closures
        if(min(input$year_pred) >= 2006) c.closures <- cod.closures %>% filter(year %in% min(input$year_pred):max(input$year_pred))
        plt.pred <- plt.pred + geom_sf(data = c.closures,fill=NA, color = 'black',size=1.5) +
                               coord_sf(xlim = x.bnd, ylim=y.bnd, expand=T)
      }
      if(input$closure == "yt")
      {
        x.bnd <- c(st_bbox(yt.closures)$xmin,st_bbox(yt.closures)$xmax)
        y.bnd <- c(st_bbox(yt.closures)$ymin,st_bbox(yt.closures)$ymax)
        if(min(input$year_pred) < 2007) y.closures <- yt.closures
        if(min(input$year_pred) >= 2007) y.closures <- yt.closures %>% filter(year %in% min(input$year_pred):max(input$year_pred))
        plt.pred <- plt.pred + geom_sf(data = y.closures,fill=NA,color= 'blue',size=1.5) +
                               coord_sf(xlim = x.bnd, ylim=y.bnd, expand=T)
      }
      
      if(input$closure == "all") 
      {
        x.bnd <- c(st_bbox(clp.pred)$xmin,st_bbox(clp.pred)$xmax)
        y.bnd <- c(st_bbox(clp.pred)$ymin,st_bbox(clp.pred)$ymax)
        plt.pred <- plt.pred + geom_sf(data = all.closures,fill=NA,
                                                                color = c("firebrick","grey50",rep("blue",13),rep('black',14),'black'),
                                                                size=1.5,linetype = c(rep("solid",29),'dashed')) +
                                                                coord_sf(xlim = x.bnd, ylim=y.bnd, expand=F)
      }
    } # end if we area adding a closure to the figure
    
     #+
                                                   #coord_sf(xlim = x.bnd, ylim=y.bnd, expand=F) # Adding in the years messes up the plot if you don't add in the coord_sf
    plt.pred  <- plot_grid(plt.pred,NULL,ncol=1,rel_heights = c(3,1))
    plt.pred

  }) # end isolate
})
```


### Closures Time Series 

-   These results show the time series for the various indicators in each of the closures and compares them to trends on Georges Bank. The *Closure* options provides the estimates for the selected indicator for the various closures on GB. The *Cod closure* and the *Yellowtail closure* are closures in Canada that are specific to the Canadian Offshore Scallop Fishery (COSF).
    - *Closed Area I* compares the selected indicator within CA I with the US portion of GB.
    - *Closed Area II* compares the selected indicator within CA II with the US portion of GB.
    - *Groundfish Closure* compares the selected indicator within US with the indicator within the Canadian groundfish closure.
    - *Cod closure* compares the selected indicator within the Cod closure with the indicator located in Canada.
    - *Yellowtail closure* compares the selected indicator within the Yellowtail closure with the indicator area located in Canada.
    
    
```{r close-ts}

renderPlot({
  input$go_pred# Tell this to update when I hit the action button.
  isolate({
     if(input$closure == 'gf') area.title <-  "Indicator in US and in Canadian Waters"
     if(input$closure == 'CA1') area.title <- "Indicator on GB-US and in CA I"
     if(input$closure == 'CA2') area.title <- "Indicator on GB-US and in CA II"
     if(input$closure == 'cod') area.title <- "Indicator in Canadian waters and Cod closure "
     if(input$closure == 'yt') area.title <-  "Indicator in Canadian waters and Yellowtail closure"
     if(input$closure == 'all')
     {
       area.ts <- ggplot() + geom_text(aes(x=1,y=1,label = 
       "The 'All closures' option doesn't do anything for the time series plots"),size=8,color='skyblue') +
                            theme_nothing()
     }
     # Set up the y-axis label.
     if(input$indicator_pred == "pred")
     { 
       yl <- "Area (km²)"
       yb = seq(0,40000,1500)
       if(input$closure %in% c("cod","yt")) yb <- seq(0,8500,250)
       ylm <- c(0,NA)
     }

     if(input$indicator_pred == "pred.sd") 
     {
       yl <- "Standard Deviation"
       yb <- pretty(c(0,0.25))
       ylm <- c(0,0.25)
     }

     if(input$indicator_pred == "sd.dist") 
     {
       yl <- "SD Distance"
       yb <- pretty(c(min(resp.era.all()$response,na.rm=T),max(resp.era.all()$response,na.rm=T)))
       ylm <- c(NA,NA)
     }

     if(input$indicator_pred == "stan.sd.dist") 
     {
       yl <- "Standardized SD Distance"
       yb <- pretty(c(min(resp.era.all()$response,na.rm=T),max(resp.era.all()$response,na.rm=T)))
       ylm <- c(NA,NA)
     }
     
     if(input$closure %in% c("CA1","CA2",'gf'))
     {
      area.ts <-  ggplot(data = resp.era.all()) +  geom_line(aes(x=year, y = as.numeric(response),color = loc),size=1.5) +
                                            geom_point(aes(x=year, y = as.numeric(response),color = loc),size=2.5) +
                                            ylab(yl) + xlab("") +# Get squared with Alt + 0178.. bam
                                            scale_y_continuous(breaks = yb, limits = ylm) +
                                            scale_x_continuous(breaks = seq(min(resp.era.all()$year),max(resp.era.all()$year),by=5)) +
                                            theme_few() + theme(text = element_text(size=22),
                                                                axis.text = element_text(size=14)) +
                                            labs(subtitle = area.title) +
                                            theme(plot.subtitle = element_text(hjust = 0.5,element_text(size = 18)),
                                                  legend.title = element_blank(),legend.position = 'right')
     }
     
     if(input$closure %in% c("cod","yt"))
     {

      area.ts <-  ggplot(data = resp.era.all()) +  geom_line(aes(x=year, y = as.numeric(response),color = loc),size=1.5) +
                                            geom_point(aes(x=year, y = as.numeric(response),color = loc),size=2.5) +
                                            ylab(yl) + xlab("") +# Get squared with Alt + 0178.. bam
                                            scale_y_continuous(breaks =yb, limits = ylm) +
                                            scale_x_continuous(breaks = seq(min(resp.era.all()$year),max(resp.era.all()$year),by=5)) +
                                            theme_few() + theme(text = element_text(size=22),
                                                                axis.text = element_text(size=14)) +
                                            labs(subtitle = area.title) +
                                            theme(plot.subtitle = element_text(hjust = 0.5,element_text(size = 18)),
                                                  legend.title = element_blank(),legend.position = 'right')
     }
    # Plot was going off the page, so added the Null underneath to keep it on the page
   area.ts <- plot_grid(area.ts,NULL,ncol=1,rel_heights = c(3,1)) 
   area.ts
   })
})

```


